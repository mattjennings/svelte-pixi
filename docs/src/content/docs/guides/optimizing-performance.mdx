---
title: Optimizing Performance
---

This page will outline a few scenarios where you may be able to optimize performance of your application. Svelte and Pixi are very performant so you won't have to think about it too much but they still have their limits!

## Rendering Lots of Components

You may find yourself needing to render and update many components at once. Take the [app on the homepage](/), for example. If we were to recreate this, we might imagine every Star as a `<Sprite />` component that receives props every frame.

```svelte live stats
<script>
  import * as PIXI from 'pixi.js'
  import { Sprite, onTick, getRenderer } from 'svelte-pixi'
  
  const { renderer } = getRenderer()

  const width = renderer.width / 2
  const height = renderer.height / 2
  const speed = 0.025
  const fov = 20
  const starSize = 0.05

  let cameraZ = $state(2000)
  let amount = $state(1000)

  // create an array describing each star's initial position
  let stars = $derived(
    new Array(amount).fill(null).map((_, i) => {
      const deg = Math.random() * Math.PI * 2
      const distance = Math.random() * 50 + 1

      return {
        key: i,
        x: Math.cos(deg) * distance,
        y: Math.sin(deg) * distance,
        z: Math.random() * 1000 + 750,
      }
    })
  )

  // move the camera forward
  onTick((delta) => {
    cameraZ += delta * 10 * speed
  })

  function getZ(star) {
    return star.z - cameraZ % 2000
  }

  function getDistance(star) {
    return Math.max(0, (2000 - getZ(star)) / 2000)
  }
</script>

<FPS />

{#each stars as star (star.key)}
  <Sprite
    texture={PIXI.Texture.from('/assets/star.png')}
    scale={getDistance(star) * starSize}
    x={star.x * width * (fov / getZ(star))}
    y={star.y * width * (fov / getZ(star))}
  />
{/each}

<label class="flex flex-col !mt-0">
  <span class="text-white text-center">Amount: {amount}</span>
  <input type="range" min="0" max="10000" step="500" bind:value={amount} />
</label>
```

Notice how the performance sharply drops as you increase the amount of stars with the slider. There are a few reasons why:

1. Updating props for thousands of components is slow. Even if these were HTML elements it would still be bad. 
At this scale it's always best to mutate the underlying Pixi instances (in this case, the sprites).

2. Mounting/unmounting thousands of components is slow. If you pay close attention you'll 
notice a significant stutter while moving the slider up/down at the higher values.

Let's take another approach by using Pixi a bit more directly:

```svelte live
<script>
  import * as PIXI from 'pixi.js'
  import { Sprite, onTick, Container, getRenderer} from 'svelte-pixi'
  import { onMount } from 'svelte'

  const { renderer } = getRenderer()

  const width = renderer.width / 2
  const height = renderer.height / 2
  const speed = 0.025
  const fov = 20
  const starSize = 0.05

  let container
  let cameraZ = $state(0)
  let amount = $state(5000)
  let stars = []


  // create stars for amount value
  $effect(() => {

    // create stars
    if (container) {
      stars = new Array(amount).fill(null).map(() => {
        // we're going to manually create our Sprite instances this time
        const star = new PIXI.Sprite(PIXI.Texture.from('/assets/star.png'))

        const deg = Math.random() * Math.PI * 2
        const distance = Math.random() * 50 + 1

        // these are custom values that we'll use in the updateStar function
        star.initX = Math.cos(deg) * distance
        star.initY = Math.sin(deg) * distance
        star.initZ = Math.random() * 1000 + 750

        star.x = star.initX
        star.y = star.initY
        star.z = star.initZ

        return star
      })

      if (stars.length) {
        container.addChild(...stars)
      }
    }

    return () => {
      // destroy stars
      stars.forEach((star) => star.destroy())
    }
  })

  // instead of updating these values as props we'll mutate them on the star instances
  function updateStar(star) {
    const z = star.z - cameraZ % 2000
    const distance = Math.max(0, (2000 - z) / 2000)

    star.scale.set(distance * starSize)
    
    star.x = star.initX * (fov / z) * width
    star.y = star.initY * (fov / z) * width
  }

  // move the camera forward
  onTick((delta) => {
    cameraZ += delta * 10 * speed

    stars.forEach(updateStar)
  })

</script>

<FPS />

<Container bind:instance={container} />

<label class="flex flex-col !mt-0">
  <span class="text-white text-center">Amount: {amount}</span>
  <input type="range" min="0" max="10000" step="500" bind:value={amount} />
</label>
```

Performance is much better now and there's hardly any stutter when adding/removing stars.

If you wanted to squeeze out a bit more you could use a [ParticleContainer](/docs/components/particle-container) instead of a regular `Container`.

## Render on Demand

Pixi applications typically render at 60 frames per second (or higher if the user's screen has a higher refresh rate). This is perfectly fine and most WebGL apps function this way, but it could be wasteful to keep rendering if everything in your scene has stopped moving or animating. In which case it would be better to only render when our components have actually updated (e.g. after user interaction).

You can set `render="demand"` on the `Application` component to opt into this behaviour:

```svelte live wrapper=/src/layouts/examples/wrappers/Empty.svelte
<script>
  import { onMount } from 'svelte'
  import { Text, Application } from 'svelte-pixi'
  import DraggableCircle from '$lib/components/DraggableCircle.svelte'
</script>

<Application
  width={700}
  height={400}
  antialias
  render="demand"
  onpostrender={() => console.log('render')}
>
  <DraggableCircle x={350} y={200} />
  <Text
    x={350}
    y={300}
    text="Click and drag"
    style={{ fill: 'white' }}
    anchor={0.5}
  />
</Application>
```

If you are using the `Renderer` component, see [this example](/docs/components/renderer#render-on-demand).

### Triggering Renders Manually

Every Svelte Pixi component will automatically trigger renders when they are updated when rendering on demand. 
If you are mutating Pixi instances directly or adding functionality to a base component you will need to mark 
that an update is required so that the canvas rerenders.

```svelte
<script>
  import { Sprite, getRenderer, onTick } from 'svelte-pixi'

  // gets the underlying Renderer component from Application
  const { invalidate } = getRenderer()

  let sprite
  let moving = true

  // we can still use the ticker!
  onTick((delta) => {
    if (sprite && moving) {
      sprite.x += 5 * delta

      if (sprite.x > 200) {
        moving = false
      }

      invalidate()
    }
  })
</script>

<Sprite bind:instance={sprite} />
```

```svelte
<!-- CustomSprite.svelte -->
<script>
  import { Sprite, getRenderer, onTick } from 'svelte-pixi'
  import { afterUpdate } from 'svelte'

  // imagine we have a custom Sprite class that extends PIXI.Sprite
  import CustomSprite from '../CustomSprite.js'

  let { customProp, customProp2, ...restProps } = $props()

  const { invalidate } = getRenderer()

  let sprite = new CustomSprite()

  // apply our custom props
  $effect(() => {
    sprite.customProp = customProp
    invalidate()
  })

  $effect(() => {
    sprite.customProp2 = customProp2
    invalidate()
  })
</script>

<Sprite instance={sprite} {...restProps} />
```
